package pl.dzielins42.stackoverflow.view;

import android.util.Log;

import com.hannesdorfmann.mosby3.mvi.MviBasePresenter;

import java.util.ArrayList;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Singleton;

import io.reactivex.BackpressureStrategy;
import io.reactivex.Flowable;
import io.reactivex.Observable;
import io.reactivex.android.schedulers.AndroidSchedulers;
import pl.dzielins42.stackoverflow.data.QueryStatus;
import pl.dzielins42.stackoverflow.data.RestQuestionDataSourceInteractor;

/**
 * Connects presentation layer and business logic layer by routing intents generated by
 * {@link MainView} to proper business logic interactors, and returning new {@link MainModel}
 * instances to be rendered by view.
 */
@Singleton
public class MainPresenter extends MviBasePresenter<MainView, MainModel> {

    private static final String TAG = MainPresenter.class.getSimpleName();

    private final RestQuestionDataSourceInteractor mQuestionDataSourceInteractor;

    @Inject
    public MainPresenter(RestQuestionDataSourceInteractor questionDataSourceInteractor) {
        super(initialModel());
        mQuestionDataSourceInteractor = questionDataSourceInteractor;
    }

    @Override
    protected void bindIntents() {
        Observable<MainModel> loadQuery =
                intent(view -> view.queryIntent().toObservable())
                        .toFlowable(BackpressureStrategy.BUFFER)
                        .doOnNext(query -> Log.d(TAG, String.format("Query: %s", query)))
                        .switchMap(query -> mQuestionDataSourceInteractor.query(query)
                                .doOnNext(queryStatus ->
                                        Log.d(TAG, String.format("QueryStatus: %s", queryStatus))
                                )
                                .publish(this::processQueryStatus)
                        )
                        .doOnNext(patch ->
                                Log.d(TAG, String.format("Patch: %s", String.valueOf(patch)))
                        )
                        .scan(initialModel(), (model, patch) -> patch.apply(model))
                        // Skip initial model
                        .skip(1)
                        .toObservable()
                        .observeOn(AndroidSchedulers.mainThread());

        subscribeViewState(loadQuery, MainView::render);
    }

    private static MainModel initialModel() {
        return MainModel.builder().build();
    }

    private Flowable<MainPatch> processQueryStatus(Flowable<QueryStatus> shared) {
        List<Flowable<MainPatch>> list = new ArrayList<>();

        list.add(shared.ofType(QueryStatus.InitialLoading.class)
                .flatMap(queryStatus -> Flowable.fromArray(
                        new MainPatch.SetInitialLoading(true),
                        new MainPatch.SetQuery(queryStatus.getQuery())
                ))
        );

        list.add(shared.ofType(QueryStatus.PageLoading.class)
                .map(queryStatus -> new MainPatch.SetPageLoading(true))
        );

        list.add(shared.ofType(QueryStatus.InitialLoaded.class)
                .map(queryStatus -> new MainPatch.SetInitialLoading(false))
        );

        list.add(shared.ofType(QueryStatus.PageLoaded.class)
                .map(queryStatus -> new MainPatch.SetPageLoading(false))
        );

        list.add(shared.ofType(QueryStatus.Error.class)
                .flatMap(e -> Flowable.fromArray(
                        new MainPatch.SetInitialLoading(false),
                        new MainPatch.SetPageLoading(false),
                        new MainPatch.SetError(e.getError()),
                        new MainPatch.SetError(null)
                ))
        );

        list.add(shared.ofType(QueryStatus.PartialResult.class)
                .map(queryStatus ->
                        (MainPatch) new MainPatch.DisplayResults(queryStatus.getQuestions())
                )
        );

        return Flowable.merge(list);
    }
}
